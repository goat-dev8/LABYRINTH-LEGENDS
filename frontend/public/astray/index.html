<html>
<head>
    <script src='Box2dWeb.min.js'></script>
    <script src="Three.js"></script>
    <script src="keyboard.js"></script>
    <script src="jquery.js"></script>
    <script src="maze.js"></script>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LABYRINTH LEGENDS - COIN RUSH MAZE GAME
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        var camera, scene, renderer, light, ambientLight,
            maze, mazeMesh, mazeDimension = 11,
            planeMesh, ballMesh, ballRadius = 0.25,
            keyAxis = [0, 0],
            gameState,
            
            // Textures
            ironTexture = THREE.ImageUtils.loadTexture('ball.png'),
            planeTexture = THREE.ImageUtils.loadTexture('concrete.png'),
            brickTexture = THREE.ImageUtils.loadTexture('brick.png'),
            
            // Game tracking
            startTime, currentLevel = 1,
            score = 0, levelScore = 0,
            
            // Collectibles
            coins = [], gems = [], stars = [],
            coinsCollected = 0, gemsCollected = 0, starsCollected = 0,
            levelCoins = 0, levelGems = 0, levelStars = 0,
            
            // Combo system
            combo = 0, comboTimer = 0, maxCombo = 0,
            lastCollectTime = 0,
            
            // Exit goal
            exitGoal = null,
            
            // Visual effects
            particles = [], screenShake = 0,

            // Box2D shortcuts
            b2World = Box2D.Dynamics.b2World,
            b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
            b2BodyDef = Box2D.Dynamics.b2BodyDef,
            b2Body = Box2D.Dynamics.b2Body,
            b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
            b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
            b2Vec2 = Box2D.Common.Math.b2Vec2,

            // Box2D world
            wWorld, wBall;

        // Helper: Create ring geometry (compatible with old Three.js)
        function createRingGeometry(innerRadius, outerRadius, segments) {
            var geometry = new THREE.Geometry();
            for (var i = 0; i <= segments; i++) {
                var angle = (i / segments) * Math.PI * 2;
                var cos = Math.cos(angle);
                var sin = Math.sin(angle);
                geometry.vertices.push(new THREE.Vector3(cos * innerRadius, sin * innerRadius, 0));
                geometry.vertices.push(new THREE.Vector3(cos * outerRadius, sin * outerRadius, 0));
            }
            for (var i = 0; i < segments; i++) {
                var a = i * 2;
                var b = i * 2 + 1;
                var c = i * 2 + 2;
                var d = i * 2 + 3;
                geometry.faces.push(new THREE.Face3(a, b, d));
                geometry.faces.push(new THREE.Face3(a, d, c));
            }
            geometry.computeFaceNormals();
            return geometry;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME CONFIGURATION PER LEVEL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function getLevelConfig(level) {
            return {
                coinCount: 8 + level * 2,           // More coins!
                gemCount: 1 + Math.floor(level / 2), // Gems worth 5x
                starCount: Math.min(level, 3),       // 1-3 bonus stars per level
                ballSpeed: 1 + (level * 0.03),
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHYSICS WORLD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createPhysicsWorld() {
            wWorld = new b2World(new b2Vec2(0, 0), true);

            // Create the ball
            var bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            bodyDef.position.Set(1, 1);
            wBall = wWorld.CreateBody(bodyDef);
            var fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.25;
            fixDef.shape = new b2CircleShape(ballRadius);
            wBall.CreateFixture(fixDef);

            // Create maze walls
            bodyDef.type = b2Body.b2_staticBody;
            fixDef.shape = new b2PolygonShape();
            fixDef.shape.SetAsBox(0.5, 0.5);
            for (var i = 0; i < maze.dimension; i++) {
                for (var j = 0; j < maze.dimension; j++) {
                    if (maze[i][j]) {
                        bodyDef.position.x = i;
                        bodyDef.position.y = j;
                        wWorld.CreateBody(bodyDef).CreateFixture(fixDef);
                    }
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER WORLD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function generate_maze_mesh(field) {
            var dummy = new THREE.Geometry();
            for (var i = 0; i < field.dimension; i++) {
                for (var j = 0; j < field.dimension; j++) {
                    if (field[i][j]) {
                        var geometry = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1);
                        var mesh_ij = new THREE.Mesh(geometry);
                        mesh_ij.position.x = i;
                        mesh_ij.position.y = j;
                        mesh_ij.position.z = 0.5;
                        THREE.GeometryUtils.merge(dummy, mesh_ij);
                    }
                }
            }
            var material = new THREE.MeshPhongMaterial({ map: brickTexture });
            return new THREE.Mesh(dummy, material);
        }

        function createRenderWorld() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 8, 20);

            // Ambient light for atmosphere
            ambientLight = new THREE.AmbientLight(0x222233);
            scene.add(ambientLight);

            // Point light following ball
            light = new THREE.PointLight(0xffaa44, 1.2, 12);
            light.position.set(1, 1, 1.3);
            scene.add(light);

            // Create ball with glow effect
            var g = new THREE.SphereGeometry(ballRadius, 32, 16);
            var m = new THREE.MeshPhongMaterial({ 
                map: ironTexture,
                emissive: 0x331100,
                emissiveIntensity: 0.3
            });
            ballMesh = new THREE.Mesh(g, m);
            ballMesh.position.set(1, 1, ballRadius);
            scene.add(ballMesh);

            // Camera
            var aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 1, 1000);
            camera.position.set(1, 1, 5);
            scene.add(camera);

            // Maze
            mazeMesh = generate_maze_mesh(maze);
            scene.add(mazeMesh);

            // Ground with darker material
            g = new THREE.PlaneGeometry(mazeDimension * 10, mazeDimension * 10, mazeDimension, mazeDimension);
            planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            planeTexture.repeat.set(mazeDimension * 5, mazeDimension * 5);
            m = new THREE.MeshPhongMaterial({ map: planeTexture, color: 0x666666 });
            planeMesh = new THREE.Mesh(g, m);
            planeMesh.position.set((mazeDimension - 1) / 2, (mazeDimension - 1) / 2, 0);
            planeMesh.rotation.set(Math.PI / 2, 0, 0);
            scene.add(planeMesh);

            // Create collectibles and exit goal
            createCollectibles();
            createExitGoal();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLECTIBLES (COINS, GEMS & STARS)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createCollectibles() {
            var config = getLevelConfig(currentLevel);
            coins = [];
            gems = [];
            levelCoins = 0;
            levelGems = 0;

            // Find valid positions (not walls, not start/end)
            var validPositions = [];
            for (var i = 1; i < maze.dimension - 1; i++) {
                for (var j = 1; j < maze.dimension - 1; j++) {
                    if (!maze[i][j] && !(i === 1 && j === 1) && !(i === mazeDimension - 1 && j === mazeDimension - 2)) {
                        validPositions.push({ x: i, y: j });
                    }
                }
            }

            // Shuffle positions
            for (var i = validPositions.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = validPositions[i];
                validPositions[i] = validPositions[j];
                validPositions[j] = temp;
            }

            // Create coins
            var coinGeom = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
            var coinMat = new THREE.MeshPhongMaterial({ 
                color: 0xffd700, 
                emissive: 0x553300,
                emissiveIntensity: 0.5,
                shininess: 100 
            });

            for (var i = 0; i < Math.min(config.coinCount, validPositions.length); i++) {
                var pos = validPositions[i];
                var coin = new THREE.Mesh(coinGeom, coinMat);
                coin.position.set(pos.x, pos.y, 0.2);
                coin.rotation.x = Math.PI / 2;
                coin.userData = { type: 'coin', collected: false, bobOffset: Math.random() * Math.PI * 2 };
                scene.add(coin);
                coins.push(coin);
            }

            // Create gems (rarer, more valuable)
            var gemGeom = new THREE.OctahedronGeometry(0.2);
            var gemMat = new THREE.MeshPhongMaterial({ 
                color: 0xff00ff, 
                emissive: 0x440044,
                emissiveIntensity: 0.7,
                shininess: 150,
                transparent: true,
                opacity: 0.8
            });

            for (var i = config.coinCount; i < Math.min(config.coinCount + config.gemCount, validPositions.length); i++) {
                var pos = validPositions[i];
                var gem = new THREE.Mesh(gemGeom, gemMat);
                gem.position.set(pos.x, pos.y, 0.3);
                gem.userData = { type: 'gem', collected: false, bobOffset: Math.random() * Math.PI * 2 };
                scene.add(gem);
                gems.push(gem);
            }

            // Create bonus stars (rare, worth 10x coins!)
            var starMat = new THREE.MeshPhongMaterial({ 
                color: 0x00ffff, 
                emissive: 0x006666,
                emissiveIntensity: 0.8,
                shininess: 200
            });

            var starIndex = config.coinCount + config.gemCount;
            for (var i = 0; i < config.starCount && starIndex < validPositions.length; i++) {
                var pos = validPositions[starIndex++];
                
                var starGroup = new THREE.Object3D();
                // Create star shape with 4 points
                for (var p = 0; p < 4; p++) {
                    var pointGeom = new THREE.CylinderGeometry(0, 0.08, 0.25, 4);
                    var point = new THREE.Mesh(pointGeom, starMat);
                    point.rotation.z = p * Math.PI / 2;
                    point.rotation.x = Math.PI / 2;
                    starGroup.add(point);
                }
                
                starGroup.position.set(pos.x, pos.y, 0.25);
                starGroup.userData = { type: 'star', collected: false, bobOffset: Math.random() * Math.PI * 2 };
                scene.add(starGroup);
                stars.push(starGroup);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXIT GOAL (Glowing portal at maze exit)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createExitGoal() {
            var exitX = mazeDimension - 1;
            var exitY = mazeDimension - 2;
            
            exitGoal = new THREE.Object3D();
            
            // Outer glow ring
            var ringGeom = createRingGeometry(0.4, 0.6, 24);
            var ringMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            var ring = new THREE.Mesh(ringGeom, ringMat);
            ring.rotation.x = -Math.PI / 2;
            exitGoal.add(ring);
            
            // Inner ring
            var innerRingGeom = createRingGeometry(0.2, 0.35, 20);
            var innerRingMat = new THREE.MeshBasicMaterial({ 
                color: 0x44ff44, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            var innerRing = new THREE.Mesh(innerRingGeom, innerRingMat);
            innerRing.rotation.x = -Math.PI / 2;
            innerRing.position.z = 0.02;
            exitGoal.add(innerRing);
            
            // Center beacon
            var beaconGeom = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
            var beaconMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 0.3
            });
            var beacon = new THREE.Mesh(beaconGeom, beaconMat);
            beacon.position.z = 0.75;
            exitGoal.add(beacon);
            
            exitGoal.position.set(exitX, exitY, 0.01);
            exitGoal.userData = { pulsePhase: 0 };
            scene.add(exitGoal);
        }

        function flashScreen(color, duration) {
            var flash = $('<div>').css({
                position: 'fixed',
                top: 0, left: 0, right: 0, bottom: 0,
                backgroundColor: '#' + color.toString(16).padStart(6, '0'),
                opacity: 0.4,
                pointerEvents: 'none',
                zIndex: 1000
            }).appendTo('body');
            
            flash.animate({ opacity: 0 }, duration * 1000, function() {
                flash.remove();
            });
        }

        function showFloatingText(text, color, size) {
            var floater = $('<div>').css({
                position: 'fixed',
                top: '40%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                color: color,
                fontSize: (size || 28) + 'px',
                fontWeight: 'bold',
                textShadow: '0 0 15px ' + color + ', 0 0 30px ' + color,
                zIndex: 1000,
                pointerEvents: 'none'
            }).text(text).appendTo('body');
            
            floater.animate({ top: '30%', opacity: 0 }, 800, function() {
                floater.remove();
            });
        }

        function showComboText() {
            if (combo >= 2) {
                var comboColor = combo >= 10 ? '#ff00ff' : (combo >= 5 ? '#00ffff' : '#ffd700');
                showFloatingText('ğŸ”¥ ' + combo + 'x COMBO!', comboColor, 24 + combo * 2);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHYSICS UPDATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updatePhysicsWorld() {
            var config = getLevelConfig(currentLevel);
            
            // Apply friction
            var lv = wBall.GetLinearVelocity();
            lv.Multiply(0.95);
            wBall.SetLinearVelocity(lv);

            // Apply user input
            var force = 0.25 * config.ballSpeed;
            var f = new b2Vec2(keyAxis[0] * wBall.GetMass() * force, keyAxis[1] * wBall.GetMass() * force);
            wBall.ApplyImpulse(f, wBall.GetPosition());
            keyAxis = [0, 0];

            wWorld.Step(1 / 60, 8, 3);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER UPDATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateRenderWorld() {
            // Update ball position
            var stepX = wBall.GetPosition().x - ballMesh.position.x;
            var stepY = wBall.GetPosition().y - ballMesh.position.y;
            ballMesh.position.x += stepX;
            ballMesh.position.y += stepY;

            // Update ball rotation
            var tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(0, 1, 0), stepX / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(1, 0, 0), -stepY / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            ballMesh.rotation.getRotationFromMatrix(ballMesh.matrix);

            // Ball glow based on combo
            if (combo >= 5) {
                ballMesh.material.emissive.setHex(combo >= 10 ? 0x440044 : 0x004444);
                ballMesh.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.2;
            } else {
                ballMesh.material.emissive.setHex(0x331100);
                ballMesh.material.emissiveIntensity = 0.3;
            }

            // Camera follow with screen shake
            var shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake * 0.015 : 0;
            var shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake * 0.015 : 0;
            screenShake = Math.max(0, screenShake - 1);
            
            camera.position.x += (ballMesh.position.x - camera.position.x) * 0.1 + shakeX;
            camera.position.y += (ballMesh.position.y - camera.position.y) * 0.1 + shakeY;
            camera.position.z += (5 - camera.position.z) * 0.1;
            
            light.position.x = camera.position.x;
            light.position.y = camera.position.y;
            light.position.z = camera.position.z - 3.7;

            // Update combo timer
            if (comboTimer > 0) {
                comboTimer--;
                if (comboTimer <= 0 && combo > 0) {
                    if (combo > maxCombo) maxCombo = combo;
                    combo = 0;
                    updateComboUI();
                }
            }

            // Animate collectibles
            var time = Date.now() * 0.003;
            coins.forEach(function(coin) {
                if (!coin.userData.collected) {
                    coin.position.z = 0.2 + Math.sin(time + coin.userData.bobOffset) * 0.05;
                    coin.rotation.z += 0.05;
                }
            });
            gems.forEach(function(gem) {
                if (!gem.userData.collected) {
                    gem.position.z = 0.3 + Math.sin(time * 1.5 + gem.userData.bobOffset) * 0.08;
                    gem.rotation.x += 0.02;
                    gem.rotation.y += 0.03;
                }
            });
            stars.forEach(function(star) {
                if (!star.userData.collected) {
                    star.position.z = 0.25 + Math.sin(time * 2 + star.userData.bobOffset) * 0.1;
                    star.rotation.z += 0.04;
                    star.rotation.x += 0.02;
                }
            });

            // Animate exit goal
            if (exitGoal) {
                exitGoal.rotation.z += 0.02;
                exitGoal.userData.pulsePhase += 0.05;
                var pulse = Math.sin(exitGoal.userData.pulsePhase) * 0.1 + 1;
                exitGoal.scale.set(pulse, pulse, 1);
                // Beacon pulses
                if (exitGoal.children[2]) {
                    exitGoal.children[2].material.opacity = 0.2 + Math.sin(exitGoal.userData.pulsePhase * 2) * 0.15;
                }
            }

            // Update particles
            for (var i = particles.length - 1; i >= 0; i--) {
                var p = particles[i];
                p.position.x += p.userData.vx;
                p.position.y += p.userData.vy;
                p.position.z += p.userData.vz;
                p.userData.vz -= 0.004; // gravity
                p.userData.life--;
                p.material.opacity = p.userData.life / 50;
                
                if (p.userData.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLISION DETECTION (Coins, Gems, Stars)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function addCombo() {
            combo++;
            comboTimer = 90; // 1.5 seconds to keep combo
            updateComboUI();
            if (combo >= 2) showComboText();
        }
        
        function checkCollisions() {
            var ballX = ballMesh.position.x;
            var ballY = ballMesh.position.y;
            var now = Date.now();

            // Check coin collection
            coins.forEach(function(coin) {
                if (!coin.userData.collected) {
                    var dx = ballX - coin.position.x;
                    var dy = ballY - coin.position.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.4) {
                        coin.userData.collected = true;
                        scene.remove(coin);
                        coinsCollected++;
                        levelCoins++;
                        
                        // Score with combo multiplier
                        var points = 100 * Math.max(1, combo);
                        score += points;
                        levelScore += points;
                        
                        addCombo();
                        updateCollectiblesUI();
                        createCollectParticles(coin.position.x, coin.position.y, 0xffd700);
                        showFloatingText('+' + points, '#ffd700', 18);
                        
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'coinCollected',
                                total: coinsCollected,
                                score: score,
                                combo: combo
                            }, '*');
                        }
                    }
                }
            });

            // Check gem collection (worth 5x!)
            gems.forEach(function(gem) {
                if (!gem.userData.collected) {
                    var dx = ballX - gem.position.x;
                    var dy = ballY - gem.position.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.45) {
                        gem.userData.collected = true;
                        scene.remove(gem);
                        gemsCollected++;
                        levelGems++;
                        
                        // Gems worth 5x coins with combo!
                        var points = 500 * Math.max(1, combo);
                        score += points;
                        levelScore += points;
                        
                        addCombo();
                        updateCollectiblesUI();
                        createCollectParticles(gem.position.x, gem.position.y, 0xff00ff);
                        flashScreen(0xff00ff, 0.15);
                        showFloatingText('+' + points + ' ğŸ’', '#ff00ff', 24);
                        screenShake = 5;
                        
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'gemCollected',
                                total: gemsCollected,
                                score: score,
                                combo: combo
                            }, '*');
                        }
                    }
                }
            });

            // Check star collection (worth 10x!)
            stars.forEach(function(star) {
                if (!star.userData.collected) {
                    var dx = ballX - star.position.x;
                    var dy = ballY - star.position.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 0.5) {
                        star.userData.collected = true;
                        scene.remove(star);
                        starsCollected++;
                        levelStars++;
                        
                        // Stars worth 10x coins with combo!
                        var points = 1000 * Math.max(1, combo);
                        score += points;
                        levelScore += points;
                        
                        addCombo();
                        updateCollectiblesUI();
                        
                        // Big celebration for stars!
                        for (var i = 0; i < 3; i++) {
                            createCollectParticles(star.position.x, star.position.y, 0x00ffff);
                        }
                        flashScreen(0x00ffff, 0.2);
                        showFloatingText('+' + points + ' â­', '#00ffff', 32);
                        screenShake = 10;
                        
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'starCollected',
                                total: starsCollected,
                                score: score,
                                combo: combo
                            }, '*');
                        }
                    }
                }
            });
        }

        function createCollectParticles(x, y, color) {
            for (var i = 0; i < 10; i++) {
                var geom = new THREE.SphereGeometry(0.05);
                var mat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 1 
                });
                var particle = new THREE.Mesh(geom, mat);
                particle.position.set(x, y, 0.3);
                particle.userData = {
                    vx: (Math.random() - 0.5) * 0.15,
                    vy: (Math.random() - 0.5) * 0.15,
                    vz: Math.random() * 0.15 + 0.05,
                    life: 40
                };
                scene.add(particle);
                particles.push(particle);
            }
        }
        
        function createVictoryParticles() {
            // Big celebration effect!
            var colors = [0xffd700, 0xff00ff, 0x00ffff, 0x00ff00];
            for (var c = 0; c < colors.length; c++) {
                for (var i = 0; i < 15; i++) {
                    var geom = new THREE.SphereGeometry(0.06);
                    var mat = new THREE.MeshBasicMaterial({ 
                        color: colors[c], 
                        transparent: true, 
                        opacity: 1 
                    });
                    var particle = new THREE.Mesh(geom, mat);
                    particle.position.set(
                        ballMesh.position.x + (Math.random() - 0.5) * 0.5,
                        ballMesh.position.y + (Math.random() - 0.5) * 0.5,
                        ballRadius
                    );
                    particle.userData = {
                        vx: (Math.random() - 0.5) * 0.25,
                        vy: (Math.random() - 0.5) * 0.25,
                        vz: Math.random() * 0.2 + 0.1,
                        life: 60
                    };
                    scene.add(particle);
                    particles.push(particle);
                }
            }
        }

        function updateCollectiblesUI() {
            $('#coins').html('ğŸª™ ' + coinsCollected);
            $('#gems').html('ğŸ’ ' + gemsCollected);
            $('#stars').html('â­ ' + starsCollected);
            $('#score').html('SCORE: ' + score.toLocaleString());
        }
        
        function updateComboUI() {
            if (combo >= 2) {
                $('#combo').html('ğŸ”¥ ' + combo + 'x').show();
            } else {
                $('#combo').hide();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function gameLoop() {
            switch (gameState) {
                case 'initialize':
                    // Use level-specific seed for deterministic maze generation
                    var levelSeed = getLevelSeed(currentLevel);
                    if (levelSeed) {
                        setMazeSeed(levelSeed);
                    }
                    
                    maze = generateSquareMaze(mazeDimension);
                    maze[mazeDimension - 1][mazeDimension - 2] = false;
                    createPhysicsWorld();
                    createRenderWorld();
                    camera.position.set(1, 1, 5);
                    light.position.set(1, 1, 1.3);
                    light.intensity = 0;
                    
                    currentLevel = Math.floor((mazeDimension - 1) / 2 - 4);
                    levelCoins = 0;
                    levelGems = 0;
                    levelStars = 0;
                    levelScore = 0;
                    combo = 0;
                    comboTimer = 0;
                    
                    $('#level').html('âš”ï¸ Level ' + currentLevel);
                    updateCollectiblesUI();
                    updateComboUI();

                    if (currentLevel === 1) {
                        startTime = Date.now();
                        score = 0;
                        coinsCollected = 0;
                        gemsCollected = 0;
                        starsCollected = 0;
                        maxCombo = 0;
                    }

                    // Notify parent with session info
                    if (window.parent !== window) {
                        window.parent.postMessage({
                            type: 'levelStart',
                            level: currentLevel,
                            time: startTime ? Date.now() - startTime : 0,
                            score: score,
                            sessionId: currentSessionId,
                            mazeSeed: getMazeSeed()
                        }, '*');
                    }

                    gameState = 'fade in';
                    break;

                case 'fade in':
                    light.intensity += 0.1 * (1.2 - light.intensity);
                    renderer.render(scene, camera);
                    if (Math.abs(light.intensity - 1.2) < 0.05) {
                        light.intensity = 1.2;
                        gameState = 'play';
                    }
                    break;

                case 'play':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    checkCollisions();
                    renderer.render(scene, camera);

                    // Update timer
                    if (startTime) {
                        var elapsed = Date.now() - startTime;
                        var mins = Math.floor(elapsed / 60000);
                        var secs = Math.floor((elapsed % 60000) / 1000);
                        var ms = Math.floor((elapsed % 1000) / 10);
                        $('#timer').html(
                            (mins < 10 ? '0' : '') + mins + ':' + 
                            (secs < 10 ? '0' : '') + secs + '.' + 
                            (ms < 10 ? '0' : '') + ms
                        );
                    }

                    // Check victory
                    var mazeX = Math.floor(ballMesh.position.x + 0.5);
                    var mazeY = Math.floor(ballMesh.position.y + 0.5);
                    if (mazeX == mazeDimension && mazeY == mazeDimension - 2) {
                        mazeDimension += 2;

                        // Level complete bonus
                        var timeBonus = Math.max(0, 60000 - (Date.now() - startTime)) / 100;
                        var levelBonus = currentLevel * 500;
                        var comboBonus = maxCombo * 100;
                        score += Math.floor(timeBonus + levelBonus + comboBonus);
                        
                        // Notify parent with session info
                        if (window.parent !== window) {
                            window.parent.postMessage({
                                type: 'levelComplete',
                                level: currentLevel,
                                time: Date.now() - startTime,
                                score: score,
                                coins: coinsCollected,
                                gems: gemsCollected,
                                stars: starsCollected,
                                maxCombo: maxCombo,
                                levelCoins: levelCoins,
                                levelGems: levelGems,
                                levelStars: levelStars,
                                sessionId: currentSessionId,
                                mazeSeed: getMazeSeed()
                            }, '*');
                        }

                        // Big victory celebration!
                        createVictoryParticles();
                        flashScreen(0x00ff00, 0.3);
                        showFloatingText('ğŸ‰ LEVEL ' + currentLevel + ' COMPLETE!', '#00ff00', 36);
                        screenShake = 15;

                        gameState = 'fade out';
                    }
                    break;

                case 'fade out':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    light.intensity += 0.1 * (0.0 - light.intensity);
                    renderer.render(scene, camera);
                    if (Math.abs(light.intensity - 0.0) < 0.1) {
                        light.intensity = 0.0;
                        renderer.render(scene, camera);
                        
                        // Clean up old objects
                        coins.forEach(function(c) { scene.remove(c); });
                        gems.forEach(function(g) { scene.remove(g); });
                        stars.forEach(function(s) { scene.remove(s); });
                        if (exitGoal) scene.remove(exitGoal);
                        particles.forEach(function(p) { scene.remove(p); });
                        
                        coins = []; gems = []; stars = []; particles = [];
                        exitGoal = null;
                        
                        gameState = 'initialize';
                    }
                    break;
            }

            requestAnimationFrame(gameLoop);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SESSION & SEED MANAGEMENT (Linera Integration)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        var currentSessionId = null;
        var sessionMazeSeed = null;
        var sessionStartTime = null;
        var levelSeeds = {}; // Cache seeds per level for deterministic regeneration

        // Listen for messages from parent (React app)
        window.addEventListener('message', function(event) {
            var data = event.data;
            if (!data || !data.type) return;
            
            switch (data.type) {
                case 'setSession':
                    // Parent sends session info before game starts
                    currentSessionId = data.sessionId;
                    sessionMazeSeed = data.mazeSeed;
                    sessionStartTime = Date.now();
                    console.log('ğŸ® Session received:', currentSessionId, 'Seed:', sessionMazeSeed);
                    
                    // Set the seed for maze generation
                    if (sessionMazeSeed) {
                        setMazeSeed(sessionMazeSeed);
                    }
                    break;
                    
                case 'setSeed':
                    // Set maze seed without session (practice mode)
                    sessionMazeSeed = data.seed;
                    if (sessionMazeSeed) {
                        setMazeSeed(sessionMazeSeed);
                    }
                    console.log('ğŸŒ± Seed set:', sessionMazeSeed);
                    break;
                    
                case 'restart':
                    // Restart game with same session/seed
                    mazeDimension = 11;
                    currentLevel = 1;
                    score = 0;
                    coinsCollected = 0;
                    gemsCollected = 0;
                    starsCollected = 0;
                    maxCombo = 0;
                    startTime = Date.now();
                    
                    // Reset seed RNG for deterministic replay
                    if (sessionMazeSeed) {
                        setMazeSeed(sessionMazeSeed);
                    }
                    
                    gameState = 'initialize';
                    break;
            }
        });

        // Generate level-specific seed (deterministic from base seed + level)
        function getLevelSeed(level) {
            if (!sessionMazeSeed) return null;
            var levelSeed = sessionMazeSeed + '-L' + level;
            return levelSeed;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        function onMoveKey(axis) {
            keyAxis = axis.slice(0);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        $(document).ready(function() {
            $('#instructions').hide();
            KeyboardJS.bind.key('i', function() { $('#instructions').show(); },
                                     function() { $('#instructions').hide(); });

            // Hide click hint on first interaction
            $(document).one('click keydown', function() {
                $('#clickHint').fadeOut(300);
            });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);

            KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
            KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);
            KeyboardJS.bind.axis('a', 'd', 's', 'w', onMoveKey);
            $(window).resize(onResize);

            gameState = 'initialize';
            requestAnimationFrame(gameLoop);
        });
    </script>

    <style>
        body {
            background: black;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            overflow: hidden;
        }

        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.92);
            color: white;
            text-align: center;
            padding: 30px 40px;
            border: 2px solid #ffd700;
            border-radius: 12px;
            z-index: 100;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.3);
        }

        #instructions h2 {
            color: #ffd700;
            margin-bottom: 20px;
            font-size: 28px;
        }

        #instructions .keys {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 15px 0;
        }

        #instructions .key {
            background: #333;
            border: 2px solid #666;
            padding: 10px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 18px;
        }

        #instructions p {
            margin: 10px 0;
            font-size: 15px;
        }

        .hud {
            position: fixed;
            padding: 8px 15px;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            z-index: 10;
        }

        #level {
            top: 10px;
            left: 10px;
            color: #ffd700;
            font-size: 24px;
        }

        #timer {
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 26px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            padding: 5px 20px;
        }

        #speedEffect {
            top: 10px;
            right: 10px;
            font-size: 20px;
            display: none;
        }

        #score {
            top: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 22px;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            padding: 5px 15px;
        }

        #coins {
            top: 50px;
            left: 10px;
            color: #ffd700;
            font-size: 18px;
        }

        #gems {
            top: 50px;
            left: 80px;
            color: #ff00ff;
            font-size: 18px;
        }

        #stars {
            top: 50px;
            left: 150px;
            color: #00ffff;
            font-size: 18px;
        }

        #combo {
            top: 85px;
            left: 10px;
            color: #ff4400;
            font-size: 24px;
            text-shadow: 0 0 10px #ff4400, 0 0 20px #ff4400;
            display: none;
        }

        #help {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #555;
            font-size: 13px;
        }

        #legend {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #888;
            font-size: 11px;
            text-align: right;
            line-height: 1.6;
        }

        #clickHint {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ffff;
            font-size: 16px;
            font-weight: bold;
            padding: 12px 24px;
            border-radius: 8px;
            border: 2px solid #00ffff;
            z-index: 100;
            animation: pulse 2s ease-in-out infinite;
            text-shadow: 0 0 10px #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateX(-50%) scale(1.05); }
        }
    </style>
</head>

<body>
    <div id="instructions">
        <h2>ğŸ° LABYRINTH LEGENDS ğŸ°</h2>
        <h3 style="color: #00ffff; margin-bottom: 15px;">COIN RUSH MODE</h3>
        <p>Navigate the ball through the maze to the exit!</p>
        <div class="keys">
            <span class="key">W</span>
            <span class="key">A</span>
            <span class="key">S</span>
            <span class="key">D</span>
        </div>
        <p style="color: #888; font-size: 13px;">or use Arrow Keys</p>
        <br>
        <p style="color: #ffd700;">ğŸª™ <b>COINS</b> = 100 pts each</p>
        <p style="color: #ff00ff;">ğŸ’ <b>GEMS</b> = 500 pts (5x value!)</p>
        <p style="color: #00ffff;">â­ <b>STARS</b> = 1000 pts (rare!)</p>
        <p style="color: #ff4400;">ğŸ”¥ <b>COMBOS</b> = Collect fast for multipliers!</p>
        <p style="color: #00ff00;">ğŸ <b>EXIT</b> = Green glowing portal</p>
        <br>
        <p style="color: #666; font-size: 12px;">Press 'I' to show/hide this help</p>
    </div>

    <div id="level" class="hud">âš”ï¸ Level 1</div>
    <div id="timer" class="hud">00:00.00</div>
    <div id="score" class="hud">SCORE: 0</div>
    <div id="coins" class="hud">ğŸª™ 0</div>
    <div id="gems" class="hud">ğŸ’ 0</div>
    <div id="stars" class="hud">â­ 0</div>
    <div id="combo" class="hud">ğŸ”¥ 1x</div>
    <div id="help">Hold 'I' for instructions | WASD or Arrow Keys to move</div>
    <div id="legend">
        ğŸª™ Coins | ğŸ’ Gems | â­ Stars | ğŸ Exit
    </div>
    <div id="clickHint">
        ğŸ‘† Click anywhere to start playing
    </div>
</body>
</html>

